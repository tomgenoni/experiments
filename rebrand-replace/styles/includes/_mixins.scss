@import "./breakpoints.json";
@import "./color";

@mixin replace-with-image(
    $url,
    $width,
    $height: $width,
    $position: center center,
    $repeat: no-repeat
) {
    border: 0;
    font: 0/0 a;
    text-shadow: none;
    color: transparent;
    background: transparent url($url) $position $repeat;
    width: $width;
    height: $height;
}

/// Media Query Generator
// Generate the rules for a given media query. Use sparingly, and create
// reusable mixins that instrument this mixin for common usages.
//
// Source: https://github.com/paranoida/sass-mediaqueries/blob/master/_media-queries.scss

@mixin mq($args...) {
    $media-type: 'only screen';
    $media-type-key: 'media-type';
    $args: keywords($args);
    $expr: '';
    @if map-has-key($args, $media-type-key) {
        $media-type: map-get($args, $media-type-key);
        $args: map-remove($args, $media-type-key);
    }
    @each $key, $value in $args {
        @if $value{
            $expr: "#{$expr} and (#{$key}: #{$value})";
        }
    }
    @media #{$media-type} #{$expr} {
        @content;
    }
}
// Get warning for missing key in a breakpoint set.
// $type - The breakpoint set
@function breakpoint-warning($type) {
    @return "Unfortunately, no matching breakpoint could be retrieved from `#{$type}`. "
        + "Please make sure it is defined in `$breakpoints` map.";
}

// Generate rule for screens no larger than the given breakpoint.
// $type - The breakpoint set ("page", "product")
// $breakpointName - "sm", "md"
@mixin no-larger-than($type, $breakpointName) {

    $breakpointSet: map-get($breakpoints, $type);

    @if map-has-key($breakpointSet, $breakpointName) {
        @include mq($max-width: map-get($breakpointSet, $breakpointName)) {
            @content;
        }
    }
    @else {
        @warn breakpoint-warning($type);
    }
}

// Generate rule for screens larger than the given breakpoint.
// $type - The breakpoint set ("page", "product")
// $breakpointName - "sm", "md"
@mixin larger-than($type, $breakpointName) {

    $breakpointSet: map-get($breakpoints, $type);

    @if map-has-key($breakpointSet, $breakpointName) {
        @include mq($min-width: map-get($breakpointSet, $breakpointName) + 1px) {
            @content;
        }
    }
    @else {
        @warn breakpoint-warning($type);
    }
}

/**
 * Mixin to clamp multiple lines of text using a fadeout and ellipsis.
 *
 * This approach works in a container of variable height with one caveat:
 * if the actual number of lines of text equals $max-lines, then the ellipsis always shows.
 */
@mixin clamp-lines(
    $line-height: 1em,
    $max-lines: 4,
    $background-color: $tp-color__white,
    $content: 'â€¦ Read More',
    $content-color: $tp-color__blue,
    $content-width: 8em
) {
    $clamped-height: $line-height * $max-lines;

    overflow: hidden;
    position: relative;
    max-height: $clamped-height;
    line-height: $line-height;

    &::after {
        cursor: pointer;
        content: $content;
        color: $content-color;
        box-sizing: content-box;
        float: right;
        position: absolute;
        top: ($max-lines - 1) * $line-height;
        right: 0;
        width: $content-width;
        text-align: right;
        background-size: 100% 100%;
        background: linear-gradient(
            to right, transparentize($background-color, 1), $background-color 20%
        );
    }

    &.clamped-lines--disabled {
        max-height: initial;

        &::after {
            display: none;
        }
    }

    & .Prose p {
        margin: $line-height 0;

        &:first-child {
            margin-top: 0;
        }

        &:last-child {
            margin-bottom: 0;
        }
    }
}

/**
 * A second mixin to clamp multiple lines of text using a fadeout and ellipsis.
 * This approach requires that the containing element have a static height equal to
 * $max-lines * $line-height. The ellipsis only shows when appropriate.
 * http://dev.mobify.com/blog/multiline-ellipsis-in-pure-css/.
 */
@mixin clamp-lines-in-static-container(
    $line-height: 1em,
    $max-lines: 2,
    $background-color: $tp-color__white,
    $content: '...',
    $content-color: $black,
    $content-width: 3em
) {
    $clamped-height: $line-height * $max-lines;
    $before-width: 5px;

    overflow: hidden;
    position: relative;
    height: $clamped-height;
    line-height: $line-height;

    &:before {
        content:"";
        float: left;
        width: $before-width;
        height: $clamped-height;
    }

    > *:first-child {
        float: right;
        width: 100%;
        margin-left: -$before-width;
    }

    &:after {
        content: $content;
        color: $content-color;
        box-sizing: content-box;
        float: right;
        position: relative;
        top: -$line-height;
        left: 100%;
        width: $content-width;
        margin-left: -$content-width;
        padding-right: $before-width;
        text-align: right;
        background-size: 100% 100%;
        background: linear-gradient(
            to right, transparentize($background-color, 1), $background-color 20%
        );
    }
}
